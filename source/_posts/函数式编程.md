---
title: Java函数式编程详解：从Lambda到Stream的完整指南
date: 2025-10-02 11:32:44
updated: 2025-10-02 11:32:44
tags: [Java, 函数式编程, Lambda, Stream, 编程范式]
categories: [Java技术, 编程思想, Lambda, Stream]
description: 深入理解Java函数式编程，从基础概念到高级应用，包含Lambda表达式、方法引用、闭包、柯里化等核心概念，以及Stream API的完整使用指南
keywords: Java函数式编程, Lambda表达式, Stream API, 方法引用, 闭包, 柯里化, 高阶函数
author: Suo
permalink: java-functional-programming-guide/
comments: true
toc: true
cover: /images/生成 Java 函数式编程封面图.png
---

# 📚 参考资源

本文档在编写过程中参考了以下优质资源，感谢这些作者和平台的分享：

## 🎥 视频教程
- **[Java函数式编程完整教程](https://www.bilibili.com/video/BV1fz421C7tj/?spm_id_from=333.337.search-card.all.click&vd_source=2d617d5367ab8a8bf8a5ed469356eb71)** - B站优质Java函数式编程教程，系统讲解了Lambda表达式和Stream API的使用

## 📖 技术博客
- **[Java Lambda Expression And Functional Programming](https://mofan212.github.io/posts/Java-Lambda-Expression-And-Functional-Programming/index.html)** - 默烦的技术博客，深入分析了Lambda表达式的底层实现原理

## 📚 推荐阅读

## 🔗 相关链接
- [Oracle官方Lambda表达式教程](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- [Oracle官方Stream API文档](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
- [美团技术团队函数式编程系列](https://tech.meituan.com/tags/函数式编程.html)

---

# 🚀 函数式编程基础

## 📖 什么是函数

函数即规则。在数学上，函数是一种映射关系，将输入值映射到输出值。
### 🔢 数学函数示例

考虑函数 $f(x) = x^2$：
| INPUT | f(x) = x² | OUTPUT |
| ----- | --------- | ------ |
| 1     | 1²        | 1      |
| 2     | 2²        | 4      |
| 3     | 3²        | 9      |
| 4     | 4²        | 16     |
| 5     | 5²        | 25     |
| ...   | ...       | ...    |

### 函数的核心特性
1. **确定性**：相同的输入总是产生相同的输出
2. **无副作用**：函数执行不会改变外部状态
3. **不变性**：函数的执行规则永远不变

> 💡 **编程启示**：在Java中，方法本质上也是函数，但绑定在对象之上。函数式编程强调不变性，这在多线程编程中意味着线程安全。

# 🎯 Lambda表达式与函数式接口
## 📝 Lambda表达式基础

在Java中，Lambda表达式是函数式编程的核心语法，它允许我们将函数作为参数传递。
### 🔄 Lambda表达式的两种形式

1. **Lambda表达式**：`(参数) -> 表达式`
2. **方法引用**：`类名::方法名` 或 `对象::方法名`

### 📋 Lambda表达式语法规则
```java
// 1. 单行表达式，可以省略大括号和return
(int a, int b) -> a + b

// 2. 多行代码，必须使用大括号和return
(int a, int b) -> {
    int c = a + b;
    return c;
}

// 3. 参数类型可以省略（类型推断）
(a, b) -> a + b

// 4. 单个参数可以省略括号
a -> a * 2
```

### 🔌 函数式接口
Lambda表达式的类型由**函数式接口**决定。函数式接口是只包含一个抽象方法的接口。
```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}
```

## 💻 实际代码示例

```java
public class LambdaExamples {
    
    // 自定义函数式接口
    @FunctionalInterface
    public interface IntCalculator {
        int calculate(int a, int b);
    }

    @FunctionalInterface
    public interface DoubleCalculator {
        double calculate(double a, double b);
    }
    
    public static void main(String[] args) {
        // 1. 明确指定参数类型
        IntCalculator lambda1 = (int a, int b) -> a + b;

        // 2. 使用类型推断（推荐）
        IntCalculator lambda2 = (a, b) -> a + b;

        // 3. 多行代码
        IntCalculator lambda3 = (a, b) -> {
        int c = a + b;
        return c + 1;
    };

        // 4. 不同返回类型
        DoubleCalculator lambda4 = (a, b) -> a + b;
        
        // 测试
        System.out.println(lambda1.calculate(5, 3)); // 输出: 8
        System.out.println(lambda2.calculate(5, 3)); // 输出: 8
        System.out.println(lambda3.calculate(5, 3)); // 输出: 9
        System.out.println(lambda4.calculate(5.5, 3.2)); // 输出: 8.7
    }
}
```



## 🔗 方法引用

方法引用是Lambda表达式的简化写法，当Lambda表达式只是调用一个已存在的方法时，可以使用方法引用。
### 📚 方法引用的四种类型
```java
public class MethodReferenceExamples {
    
    // 学生类
    static class Student {
        private String name;
        private int age;
        private String sex;
        
        public Student(String name, int age, String sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getSex() { return sex; }
    }
    
    public static void main(String[] args) {
        // 1. 类名::静态方法
        IntBinaryOperator max = Math::max;
        System.out.println(max.applyAsInt(5, 3)); // 输出: 5
        
        // 2. 类名::实例方法
        Function<Student, String> getName = Student::getName;
        Student student = new Student("张三", 20, "男");
        System.out.println(getName.apply(student)); // 输出: 张三
        
        // 3. 对象::实例方法
        Consumer<String> printer = System.out::println;
        printer.accept("Hello World"); // 输出: Hello World
        
        // 4. 类名::new (构造方法引用)
        Supplier<Student> studentCreator = Student::new;
        Student newStudent = studentCreator.get();
    }
}
```



### ⚖️ 方法引用与Lambda表达式对比
```java
public class MethodReferenceComparison {
    
    static class Student {
        private String name;
        
        public Student() {}
        public Student(String name) { this.name = name; }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
    }
    
    public static void main(String[] args) {
        // 方法引用 vs Lambda表达式对比
        // 1. 静态方法引用
        Supplier<Double> random1 = Math::random;           // 方法引用
        Supplier<Double> random2 = () -> Math.random();  // Lambda表达式
        // 2. 实例方法引用
        Function<Student, String> getName1 = Student::getName;           // 方法引用
        Function<Student, String> getName2 = student -> student.getName(); // Lambda表达式
        // 3. 对象方法引用
        Consumer<String> print1 = System.out::println;           // 方法引用
        Consumer<String> print2 = str -> System.out.println(str); // Lambda表达式
        // 4. 构造方法引用
        Supplier<Student> create1 = Student::new;           // 方法引用
        Supplier<Student> create2 = () -> new Student();     // Lambda表达式        
        // 测试
        System.out.println(random1.get());
        System.out.println(getName1.apply(new Student("张三")));
        print1.accept("Hello");
        System.out.println(create1.get());
    }
}
```

> 💡 **选择建议**：当Lambda表达式只是简单调用一个方法时，使用方法引用更简洁；当需要复杂逻辑时，使用Lambda表达式。

# 🛠️ Java内置函数式接口
## 🎨 自定义函数式接口

在Java 8之前，我们需要自己定义函数式接口。现在虽然有了内置接口，但了解自定义接口有助于理解函数式编程的本质。
```java
public class CustomFunctionalInterfaces {
    
    // 自定义函数式接口示例
    @FunctionalInterface
    public interface IntPredicate {
        boolean test(int a);
    }
    
    @FunctionalInterface
    public interface IntCalculator {
        int calculate(int a, int b);
    }
    
    @FunctionalInterface
    public interface StudentExtractor<T> {
        T getInfo(Student student);
    }
    
    @FunctionalInterface
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
    
    // 使用示例
    public static void main(String[] args) {
        IntPredicate isEven = a -> (a & 1) == 0;
        IntCalculator add = (a, b) -> a + b;
        StudentExtractor<String> getName = Student::getName;
        TriFunction<Integer, Integer, Integer, Integer> addThree = (a, b, c) -> a + b + c;
        
        System.out.println(isEven.test(4));        // true
        System.out.println(add.calculate(3, 5));   // 8
        System.out.println(addThree.apply(1, 2, 3)); // 6
    }
}
```

## 🏗️ Java内置函数式接口
Java 8提供了丰富的内置函数式接口，我们不需要重复造轮子：

### ⭐ 核心函数式接口
| 接口 | 参数 | 返回值 | 用途 | 示例 |
|------|------|--------|------|------|
| `Function<T,R>` | 1个T | R | 转换 | `Function<String,Integer> f = Integer::parseInt` |
| `BiFunction<T,U,R>` | 2个(T,U) | R | 二元转换 | `BiFunction<String,String,Integer> f = (a,b) -> a.length() + b.length()` |
| `Consumer<T>` | 1个T | void | 消费 | `Consumer<String> c = System.out::println` |
| `BiConsumer<T,U>` | 2个(T,U) | void | 二元消费 | `BiConsumer<String,Integer> c = (s,i) -> System.out.println(s + i)` |
| `Predicate<T>` | 1个T | boolean | 判断 | `Predicate<String> p = s -> s.length() > 5` |
| `BiPredicate<T,U>` | 2个(T,U) | boolean | 二元判断 | `BiPredicate<String,String> p = (a,b) -> a.equals(b)` |
| `Supplier<T>` | 无 | T | 提供 | `Supplier<String> s = () -> "Hello"` |

### 🎯 特殊化接口
```java
public class BuiltInFunctionalInterfaces {
    
    public static void main(String[] args) {
        // 1. Function系列 - 有参有返回值
        Function<String, Integer> stringToInt = Integer::parseInt;
        BiFunction<String, String, Integer> addLengths = (a, b) -> a.length() + b.length();
        
        // 2. Consumer系列 - 有参无返回值
        Consumer<String> printer = System.out::println;
        BiConsumer<String, Integer> printWithNumber = (s, i) -> System.out.println(s + ": " + i);
        
        // 3. Predicate系列 - 有参返回boolean
        Predicate<Integer> isEven = n -> n % 2 == 0;
        BiPredicate<String, String> isEqual = String::equals;
        
        // 4. Supplier系列 - 无参有返回值
        Supplier<String> greeting = () -> "Hello World";
        Supplier<LocalDateTime> now = LocalDateTime::now;
        
        // 测试
        System.out.println(stringToInt.apply("123"));     // 123
        System.out.println(addLengths.apply("Hello", "World")); // 10
        printer.accept("Hello");                          // Hello
        printWithNumber.accept("Count", 5);              // Count: 5
        System.out.println(isEven.test(4));               // true
        System.out.println(isEqual.test("hello", "hello")); // true
        System.out.println(greeting.get());               // Hello World
        System.out.println(now.get());                   // 当前时间
    }
}
```

### 🚀 原始类型特化接口

Java还提供了原始类型的特化接口，避免装箱拆箱。
```java
// IntFunction, LongFunction, DoubleFunction
IntFunction<String> intToString = String::valueOf;

// IntConsumer, LongConsumer, DoubleConsumer  
IntConsumer intPrinter = System.out::println;

// IntPredicate, LongPredicate, DoublePredicate
IntPredicate isPositive = n -> n > 0;

// IntSupplier, LongSupplier, DoubleSupplier
IntSupplier randomInt = () -> new Random().nextInt(100);
```


## 🎪 实际应用示例

```java
public class FunctionalInterfaceExamples {
    
    static class Student {
        private String name;
        private int age;
        private String sex;
        
        public Student(String name, int age, String sex) {
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getSex() { return sex; }
        
        @Override
        public String toString() {
            return "Student{name='" + name + "', age=" + age + ", sex='" + sex + "'}";
        }
    }
    
    public static void main(String[] args) {
        // 1. Predicate - 条件判断
        Predicate<Integer> isEven = a -> (a & 1) == 0;
        Predicate<Integer> isPrime = a -> BigDecimal.valueOf(a).toBigInteger().isProbablePrime(100);
        Predicate<Student> isAdult = student -> student.getAge() > 18;
        
        // 2. Function - 数据转换
        Function<Student, String> getName = Student::getName;
        Function<Student, Integer> getAge = Student::getAge;
        
        // 3. BiFunction - 二元操作
        BiFunction<Integer, Integer, Integer> add = Integer::sum;
        BiFunction<Integer, Integer, Integer> subtract = (a, b) -> a - b;
        
        // 4. TriFunction - 三元操作（自定义）
        TriFunction<Integer, Integer, Integer, Integer> addThree = (a, b, c) -> a + b + c;
        
        // 5. Supplier - 数据提供
        Supplier<Student> studentSupplier = () -> new Student("张三", 18, "男");
        Supplier<List<Student>> studentListSupplier = () -> {
            List<Student> students = new ArrayList<>();
            students.add(new Student("张三", 18, "男"));
            students.add(new Student("李四", 20, "女"));
            students.add(new Student("王五", 16, "男"));
            return students;
        };
        
        // 测试
        System.out.println("偶数判断: " + isEven.test(4));           // true
        System.out.println("素数判断: " + isPrime.test(17));         // true
        System.out.println("加法运算: " + add.apply(3, 5));         // 8
        System.out.println("减法运算: " + subtract.apply(10, 3));   // 7
        System.out.println("三元加法: " + addThree.apply(1, 2, 3)); // 6
        
        Student student = studentSupplier.get();
        System.out.println("学生信息: " + student);
        System.out.println("学生姓名: " + getName.apply(student));
        System.out.println("是否成年: " + isAdult.test(student));
        
        // 高阶函数示例
        List<Student> students = studentListSupplier.get();
        students.stream()
                .filter(isAdult)
                .map(getName)
                .forEach(System.out::println);
    }
    
    // 高阶函数：接受函数作为参数
    public static void testPredicate(Student student, Predicate<Student> predicate) {
        if (predicate.test(student)) {
            System.out.println("条件满足: " + student);
        } else {
            System.out.println("条件不满足: " + student);
        }
    }
}
```
```

# 🔍 方法引用详解

方法引用是Lambda表达式的简化形式，当Lambda表达式只是调用一个已存在的方法时，可以使用方法引用。
## 🎭 六种方法引用类型

### 1️⃣ 类名::静态方法
调用类的静态方法，参数类型和数量必须匹配。
```java
public class StaticMethodReference {
    
    public static void main(String[] args) {
        // Math类的静态方法
        Function<Double, Double> abs = Math::abs;
        BiFunction<Integer, Integer, Integer> max = Math::max;
        
        // 自定义静态方法
        Function<String, String> toUpperCase = StringUtils::toUpperCase;
        
        System.out.println(abs.apply(-5.5));        // 5.5
        System.out.println(max.apply(10, 20));      // 20
        System.out.println(toUpperCase.apply("hello")); // HELLO
    }
    
    static class StringUtils {
        public static String toUpperCase(String str) {
            return str.toUpperCase();
        }
    }
}
```

### 2️⃣ 类名::实例方法

调用实例方法，第一个参数作为方法调用的对象。
```java
public class InstanceMethodReference {
    
    public static void main(String[] args) {
        // String的实例方法
        Function<String, Integer> getLength = String::length;
        BiFunction<String, String, String> concat = String::concat;
        
        // 自定义类的实例方法
        Function<Student, String> getName = Student::getName;
        
        System.out.println(getLength.apply("Hello"));           // 5
        System.out.println(concat.apply("Hello", "World"));     // HelloWorld
        System.out.println(getName.apply(new Student("张三", 20, "男"))); // 张三
    }
}
```

### 3️⃣ 对象::实例方法

调用特定对象的实例方法。
```java
public class ObjectMethodReference {
    
    public static void main(String[] args) {
        // System.out的实例方法
        Consumer<String> printer = System.out::println;
        
        // 自定义对象的实例方法
        StringBuilder sb = new StringBuilder();
        Consumer<String> append = sb::append;
        
        printer.accept("Hello World");  // Hello World
        append.accept("Hello");
        append.accept(" ");
        append.accept("World");
        System.out.println(sb.toString()); // Hello World
    }
}
```

### 4️⃣ 类名::new (构造方法引用)

调用构造方法创建对象。
```java
public class ConstructorReference {
    
    static class Person {
        private String name;
        private int age;
        
        public Person() {
            this.name = "Unknown";
            this.age = 0;
        }
        
        public Person(String name) {
            this.name = name;
            this.age = 0;
        }
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public String toString() {
            return "Person{name='" + name + "', age=" + age + "}";
        }
    }
    
    public static void main(String[] args) {
        // 无参构造方法
        Supplier<Person> createDefault = Person::new;
        
        // 单参构造方法
        Function<String, Person> createWithName = Person::new;
        
        // 双参构造方法
        BiFunction<String, Integer, Person> createWithNameAndAge = Person::new;
        
        System.out.println(createDefault.get());                           // Person{name='Unknown', age=0}
        System.out.println(createWithName.apply("张三"));                 // Person{name='张三', age=0}
        System.out.println(createWithNameAndAge.apply("李四", 25));        // Person{name='李四', age=25}
    }
}
```

### 5️⃣ this::实例方法

在类内部引用当前对象的实例方法。
```java
public class ThisMethodReference {
    
    public void processStudents(List<Student> students) {
        // 使用this::isAdult作为过滤器
        students.stream()
                .filter(this::isAdult)
                .forEach(System.out::println);
    }
    
    private boolean isAdult(Student student) {
        return student.getAge() >= 18;
    }
    
    public static void main(String[] args) {
        ThisMethodReference processor = new ThisMethodReference();
        List<Student> students = Arrays.asList(
            new Student("张三", 20, "男"),
            new Student("李四", 16, "女"),
            new Student("王五", 22, "男")
        );
        processor.processStudents(students);
    }
}
```

### 6️⃣ super::实例方法

在子类中引用父类的实例方法。
```java
public class SuperMethodReference {
    
    static class Parent {
        protected void printInfo(String message) {
            System.out.println("Parent: " + message);
        }
    }
    
    static class Child extends Parent {
        @Override
        protected void printInfo(String message) {
            System.out.println("Child: " + message);
        }
        
        public void processData(List<String> data) {
            // 使用super::printInfo调用父类方法
            data.forEach(super::printInfo);
        }
    }
    
    public static void main(String[] args) {
        Child child = new Child();
        List<String> data = Arrays.asList("Hello", "World", "Java");
        child.processData(data);
        // 输出:
        // Parent: Hello
        // Parent: World  
        // Parent: Java
    }
}
```

## 📖 方法引用选择指南

| 场景 | 方法引用类型 | 示例 |
|------|-------------|------|
| 调用静态方法 | `类名::静态方法` | `Math::max` |
| 调用实例方法 | `类名::实例方法` | `String::length` |
| 调用对象方法 | `对象::实例方法` | `System.out::println` |
| 创建对象 | `类名::new` | `ArrayList::new` |
| 类内部引用 | `this::方法` | `this::isValid` |
| 子类引用父类 | `super::方法` | `super::toString` |

> 💡 **最佳实践**：优先使用方法引用，它比Lambda表达式更简洁，意图更明确。
# 🔐 闭包与柯里化

## 🎪 闭包（Closure）
闭包是指**函数对象**与**外部变量**绑定在一起形成的整体。在Java中，Lambda表达式可以捕获外部作用域的变量。
### 🧩 闭包的基本概念
```java
public class ClosureExample {
    
    public static void main(String[] args) {
        int x = 10; // 外部变量
        
        // Lambda表达式捕获了外部变量x，形成闭包
        Function<Integer, Integer> addX = y -> x + y;
        
        System.out.println(addX.apply(5)); // 输出: 15
    }
}
```

### ⚠️ 闭包的限制
Java中的闭包变量必须是**final**或**effectively final**的：

```java
public class ClosureLimitations {
    
    public static void main(String[] args) {
        // 1. 显式final
        final int a = 10;
        Function<Integer, Integer> addA = y -> a + y;
        
        // 2. effectively final（没有重新赋值）
        int b = 20;
        Function<Integer, Integer> addB = y -> b + y;
        
        // 3. 错误示例：不是effectively final
        int c = 30;
        // c = 40; // 如果取消注释，下面的代码会编译错误，体现了闭包不可变性和无副作用!
        // Function<Integer, Integer> addC = y -> c + y; // 编译错误
    }
}
```

### 🎯 闭包的实际应用
```java
public class ClosureApplications {
    
    public static void main(String[] args) throws IOException {
        // 创建多个任务，每个任务有不同的编号
        List<Runnable> tasks = new ArrayList<>();
        
        for (int i = 0; i < 5; i++) {
            int taskId = i + 1; // 每次循环创建新的变量
            Runnable task = () -> System.out.println(
                Thread.currentThread().getName() + ": 执行任务" + taskId
            );
            tasks.add(task);
        }
        
        // 使用虚拟线程执行任务
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
        for (Runnable task : tasks) {
            executor.submit(task);
        }
        
        executor.shutdown();
    }
}
```

### 🏗️ 闭包与对象状态
```java
public class ClosureWithObjects {
    
    static class Counter {
        private int count = 0;
        
        public void increment() {
            count++;
        }
        
        public int getCount() {
            return count;
        }
    }
    
    public static void main(String[] args) {
        Counter counter = new Counter();
        
        // Lambda表达式捕获了counter对象引用
        Runnable incrementTask = () -> {
            counter.increment();
            System.out.println("当前计数: " + counter.getCount());
        };
        
        // 执行多次
        for (int i = 0; i < 3; i++) {
            incrementTask.run();
        }
        // 输出:
        // 当前计数: 1
        // 当前计数: 2
        // 当前计数: 3
    }
}
```

## 🍛 柯里化（Currying）
柯里化是将接受多个参数的函数转换为一系列只接受一个参数的函数的技术。
### 🔧 柯里化的基本概念

```java
public class CurryingExample {
    
    // 传统方式：接受两个参数
    public static int add(int a, int b) {
        return a + b;
    }
    
    // 柯里化方式：返回一个函数
    public static Function<Integer, Integer> addCurried(int a) {
        return b -> a + b;
    }


    
    public static void main(String[] args) {
        // 传统调用
        int result1 = add(3, 5); // 8
        
        // 柯里化调用
        Function<Integer, Integer> add3 = addCurried(3);
        int result2 = add3.apply(5); // 8
        
        System.out.println("传统方式: " + result1);
        System.out.println("柯里化方式: " + result2);
    }
}
```

### 🚀 柯里化的高级应用

```java
public class AdvancedCurrying {
    
    // 定义柯里化接口
    @FunctionalInterface
    public interface CurriedFunction<T, U, R> {
        Function<U, R> apply(T t);
    }
    
    // 三元函数的柯里化
    public static CurriedFunction<Integer, Integer, Function<Integer, Integer>> 
        addThreeCurried() {
        return a -> b -> c -> a + b + c;
    }

    /*
    含义：
    接受一个 Integer 参数 a
    返回一个 Function<Integer, Function<Integer, Integer>>
    这个返回的函数接受 Integer 参数 b
    再返回一个 Function<Integer, Integer>
    最后这个函数接受 Integer 参数 c
    返回最终的 Integer 结果
    */
    
    public static void main(String[] args) {
        // 创建柯里化函数
        CurriedFunction<Integer, Integer, Function<Integer, Integer>> curriedAdd = 
            addThreeCurried();
        
        // 分步应用参数
        Function<Integer, Function<Integer, Integer>> add5 = curriedAdd.apply(5);
        Function<Integer, Integer> add5And3 = add5.apply(3);
        Integer result = add5And3.apply(2);
        
        System.out.println("结果: " + result); // 10
        
        // 链式调用
        Integer result2 = curriedAdd.apply(1).apply(2).apply(3);
        System.out.println("链式结果: " + result2); // 6
    }
}
```

### 🎪 柯里化的实际应用场景

```java
public class CurryingApplications {
    
    // 配置函数：先设置配置，再处理数据
    public static Function<String, String> createFormatter(String prefix, String suffix) {
        return data -> prefix + data + suffix;
    }
    
    // 验证函数：先设置规则，再验证数据
    public static Predicate<String> createValidator(int minLength, int maxLength) {
        return str -> str.length() >= minLength && str.length() <= maxLength;
    }
    
    public static void main(String[] args) {
        // 创建格式化器
        Function<String, String> formatter = createFormatter("[", "]");
        System.out.println(formatter.apply("Hello")); // [Hello]
        
        // 创建验证器
        Predicate<String> validator = createValidator(3, 10);
        System.out.println(validator.test("Hi"));     // false
        System.out.println(validator.test("Hello"));  // true
        System.out.println(validator.test("VeryLongString")); // false
        
        // 在Stream中使用
        List<String> words = Arrays.asList("Hi", "Hello", "World", "Java");
        words.stream()
              .filter(validator)
              .map(formatter)
              .forEach(System.out::println);
        // 输出:
        // [Hello]
        // [World]
        // [Java]
    }
}
```

## ✨ 闭包与柯里化的优势
### 1️⃣ 部分应用（Partial Application）
```java
// 先固定部分参数，后续再提供其他参数
Function<Integer, Integer> add5 = addCurried(5);
int result = add5.apply(3); // 8
```

### 2️⃣ 函数组合
```java
// 便于创建可复用的函数
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> add5AndMultiplyBy2 = addCurried(5).andThen(multiplyBy2);
```

### 3️⃣ 延迟计算
```java
// 可以在需要时才计算最终结果
Supplier<Integer> lazyCalculation = () -> addCurried(10).apply(20);
Integer result = lazyCalculation.get(); // 30
```

> 💡 **总结**：闭包让函数可以携带外部状态，柯里化让函数可以分步执行，两者都是函数式编程的重要特性。


# 🌊 Stream API详解

Stream API是Java 8引入的函数式编程核心，它提供了一种声明式的方式来处理数据集合。

> 📋 **Stream API速查表**：为了方便查阅，我为您准备了一个详细的Stream API速查表，包含了所有常用操作的语法和说明：<a href="/stream.html" target="_blank">点击查看Stream API速查表</a>
## 🌊 Stream基础概念

Stream是一个数据流，它支持顺序和并行聚合操作。Stream不是数据结构，而是对数据源的抽象。
### ⚡ Stream的特性
1. **惰性求值**：中间操作不会立即执行
2. **一次使用**：Stream只能被消费一次
3. **函数式风格**：支持链式调用
4. **并行处理**：支持并行流

## 🎯 Stream操作分类

> 💡 **提示**：如果您需要快速查阅Stream API的所有操作方法，可以参考我们的<a href="/stream.html" target="_blank">Stream API速查表</a>，它包含了完整的操作分类和语法说明。

### 1️⃣ 创建Stream

#### 🏗️ 基础创建方法
```java
public class StreamCreation {
    
    public static void main(String[] args) {
        // 1. 从集合创建
        List<String> list = Arrays.asList("Java", "Python", "C++", "JavaScript");
        Stream<String> stream1 = list.stream();
        
        // 2. 从数组创建
        String[] array = {"Hello", "World", "Java"};
        Stream<String> stream2 = Arrays.stream(array);
        
        // 3. 直接创建
        Stream<String> stream3 = Stream.of("A", "B", "C");
        
        // 4. 创建空流
        Stream<String> emptyStream = Stream.empty();
        
        // 5. 创建无限流
        Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);
        
        // 6. 生成流
        Stream<Double> randomStream = Stream.generate(Math::random);
        
        // 7. 并行流
        Stream<String> parallelStream = list.parallelStream();
    }
}
```

#### 🔢 数值流创建
```java
public class NumericStreamCreation {
    
    public static void main(String[] args) {
        // IntStream - 整数流
        IntStream intStream1 = IntStream.range(1, 5);        // 1,2,3,4 (不含5)
        IntStream intStream2 = IntStream.rangeClosed(1, 5);  // 1,2,3,4,5 (含5)
        
        // LongStream - 长整型流
        LongStream longStream = LongStream.rangeClosed(1L, 1000000L);
        
        // DoubleStream - 双精度流
        DoubleStream doubleStream = DoubleStream.of(1.1, 2.2, 3.3);
        
        // 从数组创建数值流
        int[] intArray = {1, 2, 3, 4, 5};
        IntStream fromArray = Arrays.stream(intArray);
        
        // 从集合创建数值流
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        IntStream fromCollection = numbers.stream().mapToInt(Integer::intValue);
        
        System.out.println("IntStream range: " + Arrays.toString(intStream1.toArray()));
        System.out.println("IntStream rangeClosed: " + Arrays.toString(intStream2.toArray()));
    }
}
```

#### 🔄 高级创建方法
```java
public class AdvancedStreamCreation {
    
    public static void main(String[] args) {
        // 1. 迭代创建 - 生成斐波那契数列
        Stream.iterate(new int[]{0, 1}, t -> new int[]{t[1], t[0] + t[1]})
              .limit(10)
              .map(t -> t[0])
              .forEach(System.out::println);
        
        // 2. 生成器创建 - 随机数流
        Stream.generate(() -> (int)(Math.random() * 100))
              .limit(5)
              .forEach(System.out::println);
        
        // 3. 合并流
        Stream<String> stream1 = Stream.of("A", "B", "C");
        Stream<String> stream2 = Stream.of("X", "Y", "Z");
        Stream<String> merged = Stream.concat(stream1, stream2);
        merged.forEach(System.out::println); // A B C X Y Z
        
        // 4. 构建器模式
        Stream<String> builtStream = Stream.<String>builder()
                .add("Hello")
                .add("World")
                .add("Java")
                .build();
        builtStream.forEach(System.out::println);
    }
}
```

### 2️⃣ 中间操作（Intermediate Operations）
中间操作返回新的Stream，支持链式调用。
#### 🔍 过滤（Filter）
```java
public class StreamFilter {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 过滤偶数
        List<Integer> evenNumbers = numbers.stream()
                .filter(n -> n % 2 == 0)
                .collect(Collectors.toList());
        
        System.out.println("偶数: " + evenNumbers); // [2, 4, 6, 8, 10]
        
        // 过滤大于5的数
        List<Integer> greaterThan5 = numbers.stream()
                .filter(n -> n > 5)
                .collect(Collectors.toList());
        
        System.out.println("大于5的数: " + greaterThan5); // [6, 7, 8, 9, 10]
        
        // 组合条件
        List<Integer> result = numbers.stream()
                .filter(n -> n % 2 == 0)
                .filter(n -> n > 5)
                .collect(Collectors.toList());
        
        System.out.println("偶数且大于5: " + result); // [6, 8, 10]
        
        // 使用Predicate组合
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isGreaterThan5 = n -> n > 5;
        
        List<Integer> combined = numbers.stream()
                .filter(isEven.and(isGreaterThan5))
                .collect(Collectors.toList());
        
        System.out.println("组合条件: " + combined); // [6, 8, 10]
    }
}
```

#### ✂️ 截取操作
```java
public class StreamSlicing {
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
        
        // skip - 跳过前n个元素
        List<String> skipResult = words.stream()
                .skip(2)
                .collect(Collectors.toList());
        System.out.println("跳过前2个: " + skipResult); // [cherry, date, elderberry]
        
        // limit - 限制元素数量
        List<String> limitResult = words.stream()
                .limit(3)
                .collect(Collectors.toList());
        System.out.println("限制3个: " + limitResult); // [apple, banana, cherry]
        
        // takeWhile - 取满足条件的元素（Java 9+）
        List<String> takeWhileResult = words.stream()
                .takeWhile(s -> s.length() < 7)
                .collect(Collectors.toList());
        System.out.println("长度小于7: " + takeWhileResult); // [apple, banana, cherry, date]
        
        // dropWhile - 丢弃满足条件的元素（Java 9+）
        List<String> dropWhileResult = words.stream()
                .dropWhile(s -> s.length() < 7)
                .collect(Collectors.toList());
        System.out.println("丢弃长度小于7的: " + dropWhileResult); // [elderberry]
    }
}
```

#### 🔄 去重与排序
```java
public class StreamDistinctAndSort {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3);
        
        // distinct - 去重
        List<Integer> distinct = numbers.stream()
                .distinct()
                .collect(Collectors.toList());
        System.out.println("去重: " + distinct); // [3, 1, 4, 5, 9, 2, 6]
        
        // sorted - 自然排序
        List<Integer> sorted = numbers.stream()
                .distinct()
                .sorted()
                .collect(Collectors.toList());
        System.out.println("排序: " + sorted); // [1, 2, 3, 4, 5, 6, 9]
        
        // sorted - 自定义排序
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        List<String> customSorted = words.stream()
                .sorted((a, b) -> Integer.compare(a.length(), b.length()))
                .collect(Collectors.toList());
        System.out.println("按长度排序: " + customSorted); // [date, apple, banana, cherry]
        
        // sorted - 方法引用
        List<String> methodRefSorted = words.stream()
                .sorted(Comparator.comparing(String::length))
                .collect(Collectors.toList());
        System.out.println("方法引用排序: " + methodRefSorted); // [date, apple, banana, cherry]
    }
}
```

#### 🗺️ 映射（Map）
```java
public class StreamMap {
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("hello", "world", "java", "stream");
        
        // 转换为大写
        List<String> upperCase = words.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        
        System.out.println("大写: " + upperCase); // [HELLO, WORLD, JAVA, STREAM]
        
        // 获取长度
        List<Integer> lengths = words.stream()
                .map(String::length)
                .collect(Collectors.toList());
        
        System.out.println("长度: " + lengths); // [5, 5, 4, 6]
        
        // 复杂映射
        List<String> result = words.stream()
                .map(s -> s.substring(0, 1).toUpperCase() + s.substring(1))
                .collect(Collectors.toList());
        
        System.out.println("首字母大写: " + result); // [Hello, World, Java, Stream]
    }
}
```

#### 🔄 数值流映射
```java
public class NumericStreamMapping {
    
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");
        
        // mapToInt - 转换为IntStream
        IntStream intStream = numbers.stream()
                .mapToInt(Integer::parseInt);
        System.out.println("IntStream: " + Arrays.toString(intStream.toArray())); // [1, 2, 3, 4, 5]
        
        // mapToLong - 转换为LongStream
        LongStream longStream = numbers.stream()
                .mapToLong(Long::parseLong);
        System.out.println("LongStream: " + Arrays.toString(longStream.toArray())); // [1, 2, 3, 4, 5]
        
        // mapToDouble - 转换为DoubleStream
        DoubleStream doubleStream = numbers.stream()
                .mapToDouble(Double::parseDouble);
        System.out.println("DoubleStream: " + Arrays.toString(doubleStream.toArray())); // [1.0, 2.0, 3.0, 4.0, 5.0]
        
        // 数值流操作
        List<String> words = Arrays.asList("apple", "banana", "cherry");
        int totalLength = words.stream()
                .mapToInt(String::length)
                .sum();
        System.out.println("总长度: " + totalLength); // 17
        
        // 平均值
        OptionalDouble avgLength = words.stream()
                .mapToInt(String::length)
                .average();
        avgLength.ifPresent(avg -> System.out.println("平均长度: " + avg)); // 5.67
    }
}
```

#### 🔍 调试操作
```java
public class StreamDebugging {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // peek - 调试中间结果
        List<Integer> result = numbers.stream()
                .peek(n -> System.out.println("原始: " + n))
                .filter(n -> n % 2 == 0)
                .peek(n -> System.out.println("过滤后: " + n))
                .map(n -> n * 2)
                .peek(n -> System.out.println("映射后: " + n))
                .collect(Collectors.toList());
        
        System.out.println("最终结果: " + result);
        
        // 输出：
        // 原始: 1
        // 原始: 2
        // 过滤后: 2
        // 映射后: 4
        // 原始: 3
        // 原始: 4
        // 过滤后: 4
        // 映射后: 8
        // 原始: 5
        // 最终结果: [4, 8]
    }
}
```

#### 📦 扁平化（FlatMap）
```java
public class StreamFlatMap {
    
    public static void main(String[] args) {
        List<List<String>> nestedList = Arrays.asList(
                Arrays.asList("a", "b", "c"),
                Arrays.asList("d", "e", "f"),
                Arrays.asList("g", "h", "i")
        );
        
        // 扁平化
        List<String> flattened = nestedList.stream()
                .flatMap(List::stream)
                .collect(Collectors.toList());
        
        System.out.println("扁平化结果: " + flattened); // [a, b, c, d, e, f, g, h, i]
        
        // 字符串分割示例
        List<String> sentences = Arrays.asList("Hello World", "Java Stream", "Functional Programming");
        List<String> words = sentences.stream()
                .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
                .collect(Collectors.toList());
        
        System.out.println("所有单词: " + words); // [Hello, World, Java, Stream, Functional, Programming]
    }
}
```

### 3️⃣ 终结操作（Terminal Operations）
终结操作会触发Stream的执行，返回具体的结果。
#### 📥 收集（Collect）
```java
public class StreamCollect {
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
        
        // 收集到List
        List<String> longWords = words.stream()
                .filter(s -> s.length() > 5)
                .collect(Collectors.toList());
        
        // 收集到Set
        Set<String> uniqueWords = words.stream()
                .collect(Collectors.toSet());
        
        // 收集到Map
        Map<String, Integer> wordLengthMap = words.stream()
                .collect(Collectors.toMap(
                        Function.identity(),
                        String::length
                ));
        
        // 收集到字符串
        String joined = words.stream()
                .collect(Collectors.joining(", ", "[", "]"));
        
        System.out.println("长单词: " + longWords);
        System.out.println("唯一单词: " + uniqueWords);
        System.out.println("单词长度映射: " + wordLengthMap);
        System.out.println("连接字符串: " + joined);
    }
}
```

#### 🔍 查找操作
```java
public class StreamSearch {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // findFirst - 查找第一个元素
        Optional<Integer> first = numbers.stream()
                .filter(n -> n > 5)
                .findFirst();
        System.out.println("第一个大于5的数: " + first.orElse(-1)); // 6
        
        // findAny - 查找任意一个元素（并行流中更有效）
        Optional<Integer> any = numbers.stream()
                .filter(n -> n > 5)
                .findAny();
        System.out.println("任意一个大于5的数: " + any.orElse(-1)); // 6
        
        // 并行流中的findAny
        Optional<Integer> parallelAny = numbers.parallelStream()
                .filter(n -> n > 5)
                .findAny();
        System.out.println("并行流中任意一个: " + parallelAny.orElse(-1));
        
        // 空流的情况
        Optional<Integer> empty = Stream.<Integer>empty()
                .findFirst();
        System.out.println("空流查找: " + empty.isPresent()); // false
    }
}
```

#### ✅ 匹配操作
```java
public class StreamMatching {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // anyMatch - 是否有任意一个满足条件
        boolean hasEven = numbers.stream()
                .anyMatch(n -> n % 2 == 0);
        System.out.println("是否有偶数: " + hasEven); // true
        
        // allMatch - 是否所有元素都满足条件
        boolean allPositive = numbers.stream()
                .allMatch(n -> n > 0);
        System.out.println("是否都为正数: " + allPositive); // true
        
        // noneMatch - 是否没有元素满足条件
        boolean noneNegative = numbers.stream()
                .noneMatch(n -> n < 0);
        System.out.println("是否没有负数: " + noneNegative); // true
        
        // 短路特性演示
        boolean shortCircuit = Stream.of(1, 2, 3, 4, 5)
                .peek(n -> System.out.println("检查: " + n))
                .anyMatch(n -> n > 3);
        System.out.println("短路结果: " + shortCircuit);
        // 输出：检查: 1, 检查: 2, 检查: 3, 检查: 4, 短路结果: true
        // 注意：不会检查5，因为4已经满足条件
    }
}
```

#### 🎯 聚合操作
```java
public class StreamAggregation {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // count - 计数
        long count = numbers.stream()
                .filter(n -> n % 2 == 0)
                .count();
        System.out.println("偶数个数: " + count); // 2
        
        // min - 最小值
        Optional<Integer> min = numbers.stream()
                .min(Integer::compareTo);
        System.out.println("最小值: " + min.orElse(-1)); // 1
        
        // max - 最大值
        Optional<Integer> max = numbers.stream()
                .max(Integer::compareTo);
        System.out.println("最大值: " + max.orElse(-1)); // 5
        
        // 自定义比较器
        List<String> words = Arrays.asList("apple", "banana", "cherry");
        Optional<String> shortest = words.stream()
                .min(Comparator.comparing(String::length));
        System.out.println("最短单词: " + shortest.orElse("")); // apple
        
        Optional<String> longest = words.stream()
                .max(Comparator.comparing(String::length));
        System.out.println("最长单词: " + longest.orElse("")); // banana
    }
}
```

#### 🔄 归约（Reduce）
```java
public class StreamReduce {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // 求和
        int sum = numbers.stream()
                .reduce(0, Integer::sum);
        
        // 求最大值
        Optional<Integer> max = numbers.stream()
                .reduce(Integer::max);
        
        // 求最小值
        Optional<Integer> min = numbers.stream()
                .reduce(Integer::min);
        
        // 字符串连接
        List<String> words = Arrays.asList("Hello", "World", "Java");
        String result = words.stream()
                .reduce("", (a, b) -> a + " " + b);
        
        System.out.println("求和: " + sum);           // 15
        System.out.println("最大值: " + max.get());   // 5
        System.out.println("最小值: " + min.get());   // 1
        System.out.println("连接: " + result.trim()); // Hello World Java
    }
}
```

#### 📦 高级收集器
```java
public class AdvancedCollectors {
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
        
        // 分组收集
        Map<Integer, List<String>> groupedByLength = words.stream()
                .collect(Collectors.groupingBy(String::length));
        System.out.println("按长度分组: " + groupedByLength);
        // {5=[apple, cherry], 6=[banana], 4=[date], 10=[elderberry]}
        
        // 分区收集
        Map<Boolean, List<String>> partitioned = words.stream()
                .collect(Collectors.partitioningBy(s -> s.length() > 5));
        System.out.println("按长度分区: " + partitioned);
        // {false=[apple, cherry, date], true=[banana, elderberry]}
        
        // 统计收集
        IntSummaryStatistics stats = words.stream()
                .collect(Collectors.summarizingInt(String::length));
        System.out.println("长度统计: " + stats);
        // IntSummaryStatistics{count=5, sum=31, min=4, average=6.200000, max=10}
        
        // 连接收集
        String joined = words.stream()
                .collect(Collectors.joining(", ", "[", "]"));
        System.out.println("连接结果: " + joined);
        // [apple, banana, cherry, date, elderberry]
        
        // 映射收集
        Map<String, Integer> wordToLength = words.stream()
                .collect(Collectors.toMap(
                        Function.identity(),
                        String::length,
                        (existing, replacement) -> existing // 处理重复键
                ));
        System.out.println("单词到长度映射: " + wordToLength);
    }
}
```

#### 🔄 自定义收集器
```java
public class CustomCollector {
    
    // 自定义收集器：收集为自定义对象
    static class StringStats {
        private final int count;
        private final int totalLength;
        private final String longest;
        private final String shortest;
        
        public StringStats(int count, int totalLength, String longest, String shortest) {
            this.count = count;
            this.totalLength = totalLength;
            this.longest = longest;
            this.shortest = shortest;
        }
        
        @Override
        public String toString() {
            return String.format("StringStats{count=%d, totalLength=%d, longest='%s', shortest='%s'}", 
                    count, totalLength, longest, shortest);
        }
    }
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        
        // 使用自定义收集器
        StringStats stats = words.stream()
                .collect(Collector.of(
                        () -> new StringStats(0, 0, "", ""),
                        (acc, word) -> {
                            int newCount = acc.count + 1;
                            int newTotalLength = acc.totalLength + word.length();
                            String newLongest = acc.longest.isEmpty() || word.length() > acc.longest.length() ? word : acc.longest;
                            String newShortest = acc.shortest.isEmpty() || word.length() < acc.shortest.length() ? word : acc.shortest;
                            return new StringStats(newCount, newTotalLength, newLongest, newShortest);
                        },
                        (acc1, acc2) -> new StringStats(
                                acc1.count + acc2.count,
                                acc1.totalLength + acc2.totalLength,
                                acc1.longest.length() > acc2.longest.length() ? acc1.longest : acc2.longest,
                                acc1.shortest.length() < acc2.shortest.length() ? acc1.shortest : acc2.shortest
                        )
                ));
        
        System.out.println("自定义统计: " + stats);
    }
}
```

## 🎓 Stream实际应用示例

### 📊 学生成绩处理

```java
public class StudentGradeProcessor {
    
    static class Student {
        private String name;
        private int age;
        private List<Integer> grades;
        
        public Student(String name, int age, List<Integer> grades) {
            this.name = name;
            this.age = age;
            this.grades = grades;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public List<Integer> getGrades() { return grades; }
        
        public double getAverageGrade() {
            return grades.stream()
                    .mapToInt(Integer::intValue)
                    .average()
                    .orElse(0.0);
        }
        
        @Override
        public String toString() {
            return String.format("Student{name='%s', age=%d, avgGrade=%.2f}", 
                    name, age, getAverageGrade());
        }
    }
    
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student("张三", 20, Arrays.asList(85, 90, 78, 92)),
                new Student("李四", 19, Arrays.asList(76, 88, 82, 90)),
                new Student("王五", 21, Arrays.asList(92, 95, 88, 94)),
                new Student("赵六", 20, Arrays.asList(68, 75, 72, 80)),
                new Student("钱七", 22, Arrays.asList(88, 92, 85, 90))
        );
        
        // 1. 找出平均分大于85的学生
        List<Student> excellentStudents = students.stream()
                .filter(s -> s.getAverageGrade() > 85)
                .collect(Collectors.toList());
        
        System.out.println("优秀学生:");
        excellentStudents.forEach(System.out::println);
        
        // 2. 按年龄分组
        Map<Integer, List<Student>> studentsByAge = students.stream()
                .collect(Collectors.groupingBy(Student::getAge));
        
        System.out.println("\n按年龄分组:");
        studentsByAge.forEach((age, studentList) -> {
            System.out.println("年龄 " + age + ": " + studentList.size() + " 人");
        });
        
        // 3. 计算每个年龄段的平均分
        Map<Integer, Double> averageByAge = students.stream()
                .collect(Collectors.groupingBy(
                        Student::getAge,
                        Collectors.averagingDouble(Student::getAverageGrade)
                ));
        
        System.out.println("\n各年龄段平均分:");
        averageByAge.forEach((age, avg) -> 
                System.out.printf("年龄 %d: %.2f%n", age, avg));
        
        // 4. 找出最高分的学生
        Optional<Student> topStudent = students.stream()
                .max(Comparator.comparing(Student::getAverageGrade));
        
        topStudent.ifPresent(s -> System.out.println("\n最高分学生: " + s));
    }
}
```

## ⚡ Stream性能优化

> 🔧 **性能优化参考**：更多Stream性能优化技巧和最佳实践，请参考<a href="/stream.html" target="_blank">Stream API速查表</a>中的性能优化部分。

### 1️⃣ 使用原始类型流
```java
public class StreamPerformance {
    
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                .boxed()
                .collect(Collectors.toList());
        
        // 使用IntStream（推荐）
        long start1 = System.currentTimeMillis();
        int sum1 = numbers.stream()
                .mapToInt(Integer::intValue)
                .sum();
        long end1 = System.currentTimeMillis();
        
        // 使用Stream<Integer>（较慢）
        long start2 = System.currentTimeMillis();
        int sum2 = numbers.stream()
                .reduce(0, Integer::sum);
        long end2 = System.currentTimeMillis();
        
        System.out.println("IntStream耗时: " + (end1 - start1) + "ms");
        System.out.println("Stream<Integer>耗时: " + (end2 - start2) + "ms");
    }
}
```

### 2️⃣ 并行流的使用

```java
public class ParallelStreamExample {
    
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.rangeClosed(1, 10000000)
                .boxed()
                .collect(Collectors.toList());
        
        // 串行流
        long start1 = System.currentTimeMillis();
        long count1 = numbers.stream()
                .filter(n -> n % 2 == 0)
                .count();
        long end1 = System.currentTimeMillis();
        
        // 并行流
        long start2 = System.currentTimeMillis();
        long count2 = numbers.parallelStream()
                .filter(n -> n % 2 == 0)
                .count();
        long end2 = System.currentTimeMillis();
        
        System.out.println("串行流结果: " + count1 + ", 耗时: " + (end1 - start1) + "ms");
        System.out.println("并行流结果: " + count2 + ", 耗时: " + (end2 - start2) + "ms");
    }
}
```

> 💡 **Stream最佳实践**：
> 1. 优先使用原始类型流（IntStream, LongStream, DoubleStream）
> 2. 大数据量时考虑并行流
> 3. 避免在Stream中进行复杂计算
> 4. 合理使用中间操作，避免不必要的操作
# 🎉 总结与最佳实践
## 🔄 函数式编程核心概念回顾
通过本文的学习，我们深入了解了Java函数式编程的核心概念。
### 1️⃣ 函数式编程基础
- **函数即规则**：确定性、无副作用、不变性
- **Lambda表达式**：简洁的函数表示法
- **函数式接口**：只包含一个抽象方法的接口

### 2️⃣ 核心特性
- **闭包**：函数对象与外部变量的绑定
- **柯里化**：多参数函数的分步执行
- **方法引用**：Lambda表达式的简化形式
- **Stream API**：声明式数据处理

## 🚀 性能优化建议

### 1️⃣ 选择合适的函数式接口
```java
// 推荐：使用内置接口
Predicate<String> isLong = s -> s.length() > 5;
Function<String, Integer> getLength = String::length;

// 避免：重复定义相似接口
@FunctionalInterface
public interface StringPredicate {
    boolean test(String s);
}
```

### 2️⃣ Stream性能优化
```java
// 推荐：使用原始类型流
IntStream.rangeClosed(1, 1000000)
    .filter(n -> n % 2 == 0)
    .sum();

// 避免：不必要的装箱拆箱
Stream<Integer> boxedStream = IntStream.rangeClosed(1, 1000000)
    .boxed()
    .filter(n -> n % 2 == 0)
    .mapToInt(Integer::intValue)
    .sum();
```

### 3️⃣ 并行流使用原则
```java
// 大数据量时使用并行流
List<Integer> largeList = IntStream.rangeClosed(1, 10000000)
    .boxed()
    .collect(Collectors.toList());

// 数据量小时使用串行流
List<Integer> smallList = Arrays.asList(1, 2, 3, 4, 5);
```

## 🎯 实际应用场景

### 1️⃣ 数据处理
```java
// 学生成绩统计
students.stream()
    .filter(s -> s.getAverageGrade() > 85)
    .collect(Collectors.groupingBy(Student::getAge))
    .forEach((age, list) -> System.out.println("年龄" + age + ": " + list.size() + "人"));
```

### 2️⃣ 异步编程
```java
// 异步任务处理
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(this::processData)
    .thenAccept(this::saveResult)
    .exceptionally(this::handleError);
```

### 3️⃣ 配置管理
```java
// 配置验证
Predicate<String> isValidConfig = config -> 
    config != null && !config.trim().isEmpty() && config.length() > 3;

Optional<String> validConfig = Optional.ofNullable(inputConfig)
    .filter(isValidConfig)
    .map(String::trim);
```

## ⚠️ 常见陷阱与避免方法
### 1️⃣ 闭包变量修改
```java
// 错误：修改闭包变量
int counter = 0;
Stream.of(1, 2, 3).forEach(n -> counter++); // 编译错误

// 正确：使用原子类或数组
AtomicInteger counter = new AtomicInteger(0);
Stream.of(1, 2, 3).forEach(n -> counter.incrementAndGet());
```

### 2️⃣ Stream重复使用
```java
// 错误：重复使用Stream
Stream<String> stream = list.stream();
stream.filter(s -> s.length() > 3);
stream.map(String::toUpperCase); // 运行时异常
// 正确：每次创建新的Stream
list.stream().filter(s -> s.length() > 3);
list.stream().map(String::toUpperCase);
```

### 3️⃣ 过度使用函数式编程
```java
// 错误：过度复杂化
String result = list.stream()
    .filter(s -> s != null)
    .filter(s -> !s.isEmpty())
    .map(s -> s.trim())
    .filter(s -> s.length() > 0)
    .map(s -> s.toUpperCase())
    .collect(Collectors.joining(", "));

// 正确：保持简洁
String result = list.stream()
    .filter(Objects::nonNull)
    .map(String::trim)
    .filter(s -> !s.isEmpty())
    .map(String::toUpperCase)
    .collect(Collectors.joining(", "));
```

## 📚 学习建议

1. **循序渐进**：从简单的Lambda表达式开始，逐步学习高级特性
2. **实践为主**：多写代码，多练习，在实际项目中应用
3. **性能意识**：了解性能影响，合理选择使用场景
4. **代码可读性**：函数式编程应该提高代码可读性，而不是相反
## 🎊 结语

Java函数式编程为我们提供了一种全新的编程范式，它强调不可变性、声明式编程和函数组合。通过合理使用Lambda表达式、Stream API等特性，我们可以写出更简洁、更易维护的代码。
记住，函数式编程不是银弹，它应该与传统面向对象编程相结合，在合适的场景下发挥其优势。掌握函数式编程的核心概念和最佳实践，将大大提升我们的编程能力和代码质量。

> 📚 **延伸阅读**：
> - [Java 8函数式编程](https://www.oreilly.com/library/view/java-8-in/9781449333071/)
> - [Effective Java 第三版](https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/)
> - [函数式编程思维](https://www.oreilly.com/library/view/functional-thinking/9781449365519/)


